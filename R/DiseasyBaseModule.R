#' @title Base module for diseasy
#'
#' @description
#'   The `DiseasyBaseModule` module implements common functionality that all modules have available.
#'   Most notably, the base module facilitates:
#'   * logging:
#'     A `lgr` logger is configured when making any module that inherits from the base module.
#'     This logger is stored in `private$lg`.
#'   * hashing:
#'     The active binding `self$hash` hashes the values of public fields to provide a way to uniquely identify the
#'     configuration of modules.
#'     Care must be taken to ensure that information that makes modules distinct are also stored in public fields.
#'     That is, if an important property is stored only as a private field, the hash will not change.
#'     Module-specific tests should be written to ensure hash changes as expected.
#'   * caching:
#'     The methods `private$cache()`, `private$get_hash()` `private$is_cached(hash)` implements a simple caching system
#'     whereby the results of method calls can be cached to improve the performance of the modules.
#'   * module loading:
#'     Modules instances are sometimes loaded into other modules. The `private$load_module(module)` method provides the
#'     functionality to handle this loading (including cloning of the module and passing of the new module to
#'     already-loaded modules)
#' @examples
#'   # Normally, you would not want to create this module directly, but it is possible.
#'   base_module <- DiseasyBaseModule$new()
#'
#'   rm(base_module)
#' @return
#'   A new instance of the `DiseasyBaseModule` [R6][R6::R6Class] class.
#' @export
#' @seealso [lgr][lgr::lgr]
DiseasyBaseModule <- R6::R6Class(                                                                                       # nolint: object_name_linter
  classname = "DiseasyBaseModule",

  public = list(

    #' @description
    #'   Creates a new instance of the `DiseasyBaseModule` [R6][R6::R6Class] class.
    #'   This module is typically not constructed directly but rather through derived classes.
    #' @param moduleowner (`character`)\cr
    #'   The name of the moduleowner. Used when logging.
    #' @param logging (`boolean`)\cr
    #'   Should logging be enabled?
    #' @param cache (`cachem`)\cr
    #'   A cache generated by `cachem` to use for caching results.
    initialize = function(
      moduleowner = class(self)[1],
      logging = diseasyoption("logging", self),
      cache = diseasyoption("cache", self, .default = cachem::cache_mem(max_size = Inf))
    ) {

      private$logging <- logging
      self$set_moduleowner(moduleowner)

      private$.cache <- cache
    },


    #' @description
    #'   Changes the "ownership" of the module. Used when logging.
    #' @param moduleowner (`character`)\cr
    #'   The name of the moduleowner.
    #' @return `NULL`
    set_moduleowner = function(moduleowner) {
      checkmate::assert_character(moduleowner)
      private$moduleowner <- moduleowner

      # After changing owner, update the logger
      private$update_logger()

      # Provide information that the module is loaded / changed
      private$lg$info("Module loaded")
    },


    #' @description
    #'   Loads a copy of the provided module into the module.
    #' @param module (`R6::R6Class instance`)\cr
    #'   This instance is cloned to the field with the same name as the class of the module
    #' @param clone (`boolean`)\cr
    #'   Toggle whether or not the module should be cloned when loading. Default TRUE.
    #' @details
    #'   The methods allows the setting of the internal module instances after the instance is created.
    #' @return `NULL`
    load_module = function(module, clone = TRUE) {

      # Within the `diseasy` framework, some modules includes instances of other modules.
      # One such module instance that is used across modules is the `DiseasyObservables` since
      # it is the main interface with data and many modules need data to run.

      # Here, we check this module instance for any modules it contains. For each of these nested modules, we check
      # if they require the module being loaded. If they do, we load the module into the nested instance as well.
      # This happens via recursive calls to `$load_module()` on the nested instance with `clone = FALSE`, but only
      # if the nested module does not already contain a loaded instance.

      # This way, a copy (reference) of the module being loaded is propagated to the nested modules. Any changes to the
      # parent module is then reflected in the nested instances.


      # Check the instance has a slot for the module to be loaded
      if (!paste0(".", class(module)[1]) %in% names(private)) {
        stop(glue::glue("Module {class(module)[1]} not found in {class(self)[1]}"))
      }

      # Check if the module should be cloned (i.e. a new instance is created, or if the module is used by reference)
      if (clone) {
        # Create a clone of the module
        module <- module$clone()

        # Set the ownership of the module
        module$set_moduleowner(class(self)[1])
      }


      # Determine all current diseasy modules loaded into the current instance
      nested_diseasy_modules <- as.list(private, all.names = TRUE) |>
        purrr::keep(~ inherits(., "DiseasyBaseModule"))


      # Use already loaded instances to populate the module being loaded
      purrr::walk(nested_diseasy_modules, ~ try(module$load_module(., clone = FALSE), silent = TRUE))


      # Load the module into currently nested modules
      purrr::walk(nested_diseasy_modules, ~ try(.$load_module(module, clone = FALSE), silent = TRUE))


      # Finally, store the module
      private[[glue::glue(".{class(module)[1]}")]] <- module

      # ... and track if module was cloned
      attr(private[[glue::glue(".{class(module)[1]}")]], "clone") <- clone

    },


    #' @description
    #'   Handles the clean-up of the class
    finalize = function() {
      # Look for contained Diseasy* classes and call finalize on these
      private |>
        as.list(all.names = TRUE) |>
        purrr::keep(~ inherits(., "DiseasyBaseModule")) |>
        purrr::discard(~ isTRUE(attr(., "clone"))) |>
        purrr::walk(~ .$finalize())
    }
  ),

  active = list(

    #' @field hash (`character`)\cr
    #' Computes a hash value for the module. Useful for logging and caching. Read only.
    hash = purrr::partial(
      .f = active_binding,
      name = "hash",
      expr = {
        # Capture module environment (parent of this environment)
        public_names <- ls(self) # public (fields and functions)
        public_names <- public_names[public_names != "hash"] # avoid recursion
        public_env <- public_names |>
          purrr::map(~ {
            # Some of the active bindings return informative errors when a module is
            # not fully configured. This should not stop the hashing process, so we capture the
            # errors and hash these instead
            tryCatch(purrr::pluck(self, .), error = function(e) e)
          })
        names(public_env) <- public_names

        # Iteratively map the public environment to hashes
        hash_list <- hash_environment(public_env)

        # Add the class name to "salt" the hashes
        hash_list <- c(hash_list, class = class(self)[1])

        # Reduce to single hash and return
        hash <- withr::with_locale(
          new = c("LC_COLLATE" = "C"), # Ensure consistent hashing
          rlang::hash(hash_list[order(names(hash_list))])
        )
        return(hash)
      }
    )
  ),

  private = list(

    # @field lg (`lgr::LoggerGlue`)\cr
    #   Contains the logging module
    lg = NULL,
    logging = NULL,

    # @field moduleowner (`moduleowner`)\cr
    #   Stores the "moduleowner" as given by set_moduleowner()
    moduleowner = NULL,

    # @description
    #   Updates the logger (should be called when modelowner changes).
    #   This adjusts the logging format to include the modelowner in parentheses
    # @return `NULL`
    update_logger = function() {

      # Look for active logger, if not found, create active logger
      # Each subclass gets its own logger
      private$lg <- lgr::get_logger_glue(
        glue::glue_collapse(
          c("mgmodel", private$moduleowner, class(self)[1]),
          sep = "/"
        )
      )

      # Disable logging if needed
      if (isFALSE(private$logging)) {
        private$lg$set_appenders(list())

      } else if (length(private$lg$appenders) == 0 && !testthat::is_testing()) {

        # Appenders
        appenders <- list(cons = lgr::AppenderConsole$new())

        # Check if logs are used
        if (dir.exists("logs")) {
          log_path <- glue::glue("logs/{lubridate::today()}.log")
          appenders <- c(appenders, file = lgr::AppenderFile$new(log_path))
        }

        # Set appenders
        private$lg$set_appenders(appenders)

        # Add moduleowner name to the format
        if (is.null(private$moduleowner) || class(self)[1] == private$moduleowner) { # if owned by self, don't put owner
          fmt <- class(self)[1]
        } else {
          fmt <- glue::glue("({private$moduleowner}) {class(self)[1]}")
        }

        purrr::map(
          private$lg$appenders,
          ~ .$set_layout(
            lgr::LayoutGlue$new(
              fmt = paste0("{pad_right(colorize_levels(toupper(level_name)), 5)} [{timestamp}] ", fmt, ": {msg}")
            )
          )
        )
      }

      # Don't propagate to parent loggers
      private$lg$set_propagate(FALSE)
    },

    # @field .cache (`list()`)\cr
    #   A named list of cached elements (name is the hash)
    .cache = NULL,

    # @description
    #   Retrieve or put results in the the cache
    # @param hash (`character`)\cr
    #   The hash corresponding to the result
    # @param obj (`object`)\cr
    #   If given, the data will be stored in the .cache list. \cr
    #   If no object is given, the function returns the object located at the hash
    # @return
    #   (`NULL`) if object is given\cr
    #   (`object`) if no object is given
    #' @import cachem
    cache = function(hash, obj) {
      if (missing(obj)) {

        obj <- private$.cache$get(hash)
        if (cachem::is.key_missing(obj)) {
          stop("Hash not found in cache!")
        }
        return(obj)

      } else {

        if (private$.cache$exists(hash)) {
          stop("Hash already found in cache!")
        } else {
          private$.cache$set(hash, obj)
        }

      }
    },

    # @description
    #   Looks for the hash in the cache
    # @param hash (`character`)\cr
    #   The hash to search the cache for
    # @return (`bool`)\cr
    #   Boolean that indicates if the hash is found
    is_cached = function(hash) {
      return(private$.cache$exists(hash))
    },

    # @description
    #   Function that parses the given environment to a unique hash.
    # @param function_environment (`environment`)\cr
    #   The environment of the function to hash.
    # @return (`character`)\cr
    #   The values in the function environment is hashed and combined with the classname and hash of the parent
    #   environment
    get_hash = function(function_environment = rlang::caller_env()) {

      # Find all relevant hashes
      hash_list <- c(
        module_hash = self$hash, # Hash of the module (state of public fields)
        hash_environment(function_environment), # hash everything in the function environment
        class = class(self)[1] # And add the module name to the hash
      )

      # Reduce to single hash and return
      hash <- withr::with_locale(
        new = c("LC_COLLATE" = "C"), # Ensure consistent hashing
        rlang::hash(hash_list[order(names(hash_list))])
      )
      return(substring(hash, 1, 10))
    },


    # Errors
    read_only_error = function(field) {
      stop(glue::glue("`${field}` is read only"), call. = FALSE)
    },

    not_implemented_error = function(...) {
      stop("Not implemented: ", glue::glue_collapse(c(...), sep = " "), call. = FALSE)
    },

    # Common logging
    report_get_results = function(observable, stratification, prediction_length, hash) {
      private$lg$info(
        "Providing prediction of {observable}",
        ifelse(is.null(stratification), "", " at stratification: {private$stratification_to_string(stratification)}"),
        " for a period of {prediction_length} days",
        " (hash: {hash})"
      )
    },



    # @description
    #   Converts an aggreagtion to human readable form
    # @param stratification (`list`(`quosure`))\cr
    #   An quosure passed as aggregator
    # @return (`character`)\cr
    #   A comma separated character string of the different stratification levels
    stratification_to_string = function(stratification) {
      if (is.null(stratification)) {
        stratification_chr <- NA_character_
      } else {
        stratification_chr <- purrr::imap(purrr::map(stratification, dplyr::as_label),
                                          ~ ifelse(.y == "", .x, glue::glue_collapse(c(.y, .x), sep = " = "))) |>
          toString()
      }
      return(stratification_chr)
    }
  )
)


#' @name plot
#' @title
#'   Plotting method for `diseasy` modules
#' @description
#'   Visualise `diseasy` modules.
#' @param x (`Diseasy*`)\cr
#'   The module to generate visualisation for.
#' @param ...
#'   Parameters sent to the specific plotting methods.
#'   See the `$plot()` method for each module
#' @return `r rd_side_effects`
#' @examples
#'   immunity <- DiseasyImmunity$new()
#'   plot(immunity)
#'
#'   immunity$set_exponential_waning(target = "hospitalisation")
#'   plot(immunity)
#'
#'   rm(immunity)
#' @export
plot.DiseasyBaseModule <- function(x, ...) {
  x$plot(...)
}


# Set default options for the package related to DiseasyObservables
rlang::on_load({
  options("diseasy.logging" = FALSE)
})
