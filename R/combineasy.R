#' Easily combine modules and parameters to form a model ensemble
#' @param model_generators list(`DiseasyModel`)\cr
#'   Provide a list of generators (factories) that will be initialized with modules and parameters
#' @param modules `tibble`\cr
#'   The combination of modules to load into the model instances (generated by `tidyr`::`expand_grid`)
#' @param ... \cr
#'   A named set of parameters and their combinations to set in the model. Each name must match a name in the parameters
#'   of the model. All combinations of parameters will used for each combination of modules.
#' @seealso [tidyr::expand_grid]
#' @export
combineasy <- function(model_generators, modules = NULL, ...) {

  coll <- checkmate::makeAssertCollection()

  checkmate::assert_list(model_generators, add = coll) # TODO: check that each element has the right class

  # Check that all model_generators have the model class
  is_model_generator <- purrr::map_lgl(model_generators, ~ inherits(.x$new(), "DiseasyModel"))
  if (any(!is_model_generator)) {
    coll$push(glue::glue("Index {which(!is_model_generator)} of model_generators is not of class `DiseasyModel`"))
  }

  # Check all modules have the correct class
  if (!is.null(modules)) {
    module_classes <- modules |>
      utils::head(1) |>
      dplyr::mutate(dplyr::across(tidyselect::everything(), \(col) purrr::map_chr(col, ~ purrr::pluck(class(.), 1)))) |>
      unlist()

    disallowed_module <- module_classes |>
      purrr::discard( ~ . %in% c("DiseasyObservables", "DiseasyActivity", "DiseasySeason"))

    purrr::walk2(
      disallowed_module,
      names(disallowed_module),
      ~ {
        coll$push(
          glue::glue(
            "modules element {.y} has unaccepted class '{.x}'. ",
            "Must be one of `DiseasyObservables`, `DiseasyActivity`, `DiseasySeason`"
          )
        )
      }
    )
  }

  # Create empty instances of the models
  models_empty <- purrr::map(model_generators, ~ .x$new())

  # Determine available model parameters
  model_parameters <- purrr::map(models_empty, ~ names(.x$parameters))
  common_model_parameters <- purrr::reduce(model_parameters, intersect)

  # Capture the set parameters
  parameter_names <- names(list(...))

  # Check that given parameters match model parameters
  if (!all(parameter_names %in% common_model_parameters)) {
    # Determine issue with given parameter
    # 1) Parameters are in none of the models
    none <- purrr::discard(parameter_names, \(p) purrr::some(model_parameters,  ~ p %in% .x))
    purrr::walk(none, ~ coll$push(glue::glue("Parameter `{.x}` not found in any of the given model generators")))

    # 2) Parameters are in some of the models
    parameter_names |>
      purrr::discard(\(p) purrr::every(model_parameters, ~ p %in% .x)) |>
      setdiff(none) |>
      purrr::walk(
        ~ coll$push(glue::glue("Parameter `{.x}` only found in some, not all, of the given model generators"))
      )
  }

  # Report assertions
  checkmate::reportAssertions(coll)

  # First, we initialize the models with the modules
  models_modules_loaded <- models_empty |>
    purrr::map(\(model) { # We iterate over all models

      # And make an inner loop over the module combination to load
      purrr::map(
        seq_len(nrow(modules)),
        \(module_combination) {

          # We must clone the model before loading new modules
          model <- model$clone()

          # Then load each module in turn
          unlist(modules[module_combination, ]) |>
            purrr::walk(~ model$load_module(.))

          # Then return the model
          model
        }
      )
    }) |>
    purrr::flatten()

  # Then, we initialize the models with each combination of parameters
  parameters <- tidyr::expand_grid(...)

  # Return early, if no parameters are to be set
  if (ncol(parameters) == 0)  {
    return(models_modules_loaded)
  }
  # Apparently, the tibble output of expand_grid with no input thinks it has one record, even though it does not.
  # So we have to use ncol over nrow...

  models_fully_loaded <- models_modules_loaded |>
    purrr::map(\(model) { # We iterate over all models

      # And make an inner loop over the parameter combination to load
      purrr::map(
        seq_len(nrow(parameters)),
        \(parameter_combination) {

          # We must clone the model before setting new parameters
          model <- model$clone()

          # Then load each module in turn
          params <- parameters[parameter_combination, ]
          purrr::walk2(params, names(params), \(p, np) model$.__enclos_env__$private$.parameters[np] <- p)

          # Then return the model
          model
        }
      )
    }) |>
    purrr::flatten()

  return(models_fully_loaded)
}
