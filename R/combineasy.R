#' Easily combine modules and parameters to form a model ensemble
#' @param model_templates (`list`(`DiseasyModel`))\cr
#'   Provide a list of model templates that will be initialized with (functional) modules and parameters.
#' @param modules (`tibble`)\cr
#'   The combination of modules to load into the model instances (generated by `tidyr`::`expand_grid`).
#' @param parameters (`tibble`)\cr
#'   The combination of parameters to set in the model instances (generated by `tidyr`::`expand_grid`).
#' @seealso [tidyr::expand_grid]
#' @export
combineasy <- function(model_templates, modules = NULL, parameters = NULL) {

  coll <- checkmate::makeAssertCollection()

  if (is.null(modules) && is.null(parameters)) {
    coll$push("Either modules or parameters must be provided!")
  }

  checkmate::assert_list(model_templates, add = coll)

  # Check that all model_templates have the model class
  is_model_generator <- purrr::map_lgl(model_templates, ~ inherits(.x$new(), "DiseasyModel"))
  if (any(!is_model_generator)) {
    coll$push(glue::glue("Index {which(!is_model_generator)} of model_templates is not of class `DiseasyModel`"))
  }

  # Create empty instances of the models
  models_empty <- purrr::map(model_templates, ~ .x$new())

  # Determine available model parameters
  model_parameters <- purrr::map(models_empty, ~ names(.x$parameters))
  common_model_parameters <- purrr::reduce(model_parameters, intersect)

  # Check that given parameters match model parameters
  parameter_names <- colnames(parameters)
  if (!all(parameter_names %in% common_model_parameters)) {
    # Determine issue with given parameter
    # 1) Parameters are in none of the models
    none <- purrr::discard(parameter_names, \(p) purrr::some(model_parameters,  ~ p %in% .x))
    purrr::walk(none, ~ coll$push(glue::glue("Parameter `{.x}` not found in any of the given model generators")))

    # 2) Parameters are in some of the models
    parameter_names |>
      purrr::discard(\(p) purrr::every(model_parameters, ~ p %in% .x)) |>
      setdiff(none) |>
      purrr::walk(
        ~ coll$push(glue::glue("Parameter `{.x}` only found in some, not all, of the given model generators"))
      )
  }

  # Report assertions
  checkmate::reportAssertions(coll)

  # First, we initialize the models with the modules
  if (is.null(modules)) {
    models_modules_loaded <- models_empty
  } else {
    models_modules_loaded <- models_empty |>
      purrr::map(\(model) { # We iterate over all models

        # And make an inner loop over the module combination to load
        purrr::map(
          seq_len(nrow(modules)),
          \(module_combination) {

            # We must clone the model before loading new modules
            model <- model$clone()

            # Then load each module in turn
            unlist(modules[module_combination, ]) |>
              purrr::walk(~ model$load_module(.))

            # Then return the model
            model
          }
        )
      }) |>
      purrr::flatten()
  }


  # Set the parameters if given
  if (is.null(parameters))  {
    models_fully_loaded <- models_modules_loaded
  } else {
    models_fully_loaded <- models_modules_loaded |>
      purrr::map(\(model) { # We iterate over all models

        # And make an inner loop over the parameter combination to load
        purrr::map(
          seq_len(nrow(parameters)),
          \(parameter_combination) {

            # We must clone the model before setting new parameters
            model <- model$clone()

            # Then load each module in turn
            params <- parameters[parameter_combination, ]
            purrr::walk2(params, names(params), \(p, np) model$.__enclos_env__$private$.parameters[np] <- p)

            # Then return the model
            model
          }
        )
      }) |>
      purrr::flatten()
  }

  # Set the class
  class(models_fully_loaded) <- c("DiseasyEnsemble", "list")

  return(models_fully_loaded)
}
